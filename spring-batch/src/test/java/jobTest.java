/*
 * This Java source file was generated by the Gradle 'init' task.
 */
import batch.DBBatchConfig;
import batch.DBManager;
import org.junit.Test;
import org.springframework.batch.core.*;
import org.springframework.batch.core.configuration.JobFactory;
import org.springframework.batch.core.configuration.JobLocator;
import org.springframework.batch.core.configuration.JobRegistry;
import org.springframework.batch.core.configuration.annotation.EnableBatchProcessing;
import org.springframework.batch.core.configuration.annotation.JobBuilderFactory;
import org.springframework.batch.core.configuration.annotation.StepBuilderFactory;
import org.springframework.batch.core.configuration.support.AutomaticJobRegistrar;
import org.springframework.batch.core.configuration.support.JobRegistryBeanPostProcessor;
import org.springframework.batch.core.configuration.support.MapJobRegistry;
import org.springframework.batch.core.configuration.support.ReferenceJobFactory;
import org.springframework.batch.core.explore.JobExplorer;
import org.springframework.batch.core.job.flow.FlowJob;
import org.springframework.batch.core.jsr.configuration.xml.JobFactoryBean;
import org.springframework.batch.core.launch.JobExecutionNotRunningException;
import org.springframework.batch.core.launch.JobLauncher;
import org.springframework.batch.core.launch.JobOperator;
import org.springframework.batch.core.launch.support.RunIdIncrementer;
import org.springframework.batch.core.launch.support.SimpleJobOperator;
import org.springframework.batch.core.partition.support.Partitioner;
import org.springframework.batch.core.repository.JobRepository;
import org.springframework.batch.core.scope.context.ChunkContext;
import org.springframework.batch.core.scope.context.StepSynchronizationManager;
import org.springframework.batch.core.scope.context.SynchronizationManagerSupport;
import org.springframework.batch.core.step.NoSuchStepException;
import org.springframework.batch.core.step.StepLocator;
import org.springframework.batch.core.step.tasklet.StoppableTasklet;
import org.springframework.batch.core.step.tasklet.Tasklet;
import org.springframework.batch.core.step.tasklet.TaskletStep;
import org.springframework.batch.item.ItemReader;
import org.springframework.batch.item.NonTransientResourceException;
import org.springframework.batch.item.ParseException;
import org.springframework.batch.item.UnexpectedInputException;
import org.springframework.batch.repeat.RepeatStatus;
import org.springframework.beans.factory.config.PropertyPlaceholderConfigurer;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;
import org.springframework.context.support.GenericXmlApplicationContext;
import org.springframework.core.env.PropertySource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.transaction.interceptor.TransactionProxyFactoryBean;
import org.vibur.dbcp.ViburDBCPDataSource;

import javax.sql.DataSource;
import java.io.FileInputStream;
import java.util.*;
import java.util.stream.Collectors;


public class jobTest {



    /**
     * 10초동안 잠자는 작업
     */
    public static class MyTasklet implements Tasklet {



        private  int i=0;
        @Override
        public RepeatStatus execute(StepContribution arg0, ChunkContext arg1) throws Exception {



            int commitCount = arg1.getStepContext().getStepExecution().getCommitCount();
            int skipCount = arg0.getSkipCount();

            System.out.println("Hello This is a MyTasklet : "+commitCount);
            System.out.println("Hello This is a MyTasklet : "+skipCount);
            Thread.sleep(1000);
            i++;
            if(i<=5) {
                System.out.println("--Hello This is a CONTINUABLE i=  : "+i);
                arg1.getStepContext().getStepExecution().getExecutionContext().put("tset","test11");
                arg1.getStepContext().getJobExecutionContext().put("tset","test11");

                return RepeatStatus.CONTINUABLE;
            }else
            {
               return RepeatStatus.FINISHED;
            }


        }
    }
    /**
     * 10초동안 잠자는 작업
     */
    public static class MyTasklet2 implements Tasklet {

        @Override
        public RepeatStatus execute(StepContribution arg0, ChunkContext arg1) throws Exception {

            int commitCount = arg1.getStepContext().getStepExecution().getCommitCount();
            int skipCount = arg0.getSkipCount();

            System.out.println("Hello This is a sMyTasklet2: "+commitCount);
            System.out.println("Hello This is a sMyTasklet2 : "+skipCount);
            Thread.sleep(1000);








            return RepeatStatus.CONTINUABLE;
        }
    }

    /**
     * DataSource 설정
     * @param datasourceUrl
     * @param dbDriverClassName
     * @param dbUsername
     * @param dbPassword
     * @return
     */
    public DataSource getDataSource(   String datasourceUrl,
                                      String dbDriverClassName,
                                      String dbUsername,
                                     String dbPassword)
    {
        ViburDBCPDataSource dataSource = new ViburDBCPDataSource();

        dataSource.setJdbcUrl(datasourceUrl);
        dataSource.setDriverClassName(dbDriverClassName);
        // dataSource.setUrl(datasourceUrl);
        dataSource.setUsername(dbUsername);
        dataSource.setPassword(dbPassword);

        dataSource.setPoolInitialSize(10);
        dataSource.setPoolMaxSize(100);

        dataSource.setConnectionIdleLimitInSeconds(30);


        dataSource.setLogQueryExecutionLongerThanMs(500);
        dataSource.setLogStackTraceForLongQueryExecution(true);

        dataSource.setStatementCacheMaxSize(200);

        dataSource.start();

        return dataSource;
    }


    /**
     * 확인 : tasklet 이 2개가 존재할 때 첫번째 tasklet 이 완료 된 후 다음 tasklet이 동작하는지 아니면 첫번째 tasklet이 다 완료된 후 2번째 tasklet이 동작하는지 확인하는 것이다.
     * 결과 : 하나의 step 이 완료되어야 다음 step으로 넘어간다.
     * @throws Exception
     */
   // @Test
    public void taskletContinueTest() throws Exception {
        DataSource dataSource = getDataSource("jdbc:mysql://192.168.0.2:3306/oauth2?useSSL=false&characterEncoding=utf-8", "com.mysql.cj.jdbc.Driver"
                , "shh", "shh");
        DBManager dbManager = new DBManager(dataSource);

        DBBatchConfig DBBatchConfig = new DBBatchConfig(dataSource);

        JobBuilderFactory jobBuilderFactory = DBBatchConfig.getJobBuilderFactory();

        StepBuilderFactory stepBuilderFactory = DBBatchConfig.getStepBuilderFactory();

        JobOperator jobOperator = DBBatchConfig.getJobOperator();

        JobRegistry jobRegistry = DBBatchConfig.getJobRegistry();

        JobExplorer jobExplorer = DBBatchConfig.getJobExplorer();




        TaskletStep step1 = stepBuilderFactory.get("step1").tasklet(new MyTasklet()).build();

        TaskletStep step2 = stepBuilderFactory.get("step2").tasklet(new MyTasklet2()).build();
        Job test = jobBuilderFactory.get("test").start(step1).next(step2)
                .listener(new JobExecutionListener() {
                    @Override
                    public void beforeJob(JobExecution jobExecution) {
                        System.out.println("beforeJob");
                    }

                    @Override
                    public void afterJob(JobExecution jobExecution) {
                        System.out.println("afterJob");
                    }
                }).build();

        JobLauncher jobLauncher = DBBatchConfig.getJobLauncher();

        JobParameters jobParameters = new JobParametersBuilder().addLong("time", System.currentTimeMillis())
                .toJobParameters();

        jobRegistry.register(new ReferenceJobFactory(test));
        JobExecution run = jobLauncher.run(test, jobParameters);


        Thread.sleep(5000);


        try {
            run.stop();
        }finally {

        }

     // jobOperator.stop(run.getJobId());


        JobExecution jobExecution = jobExplorer.getJobExecution(run.getJobId());
        Long time = jobExecution.getJobParameters().getLong("time");
        System.out.println("para ="+time);


        System.in.read();
    }


    /**
     * job 파라미터가 같은 해쉬를 가지면 두번다시는 동일한 실행을 하지 못한다. 따라서 UUID 나 시간등을 주어 Job 파라미터 해쉬값을 바꾸어야 한다.
     * @throws Exception
     */
    @Test
    public void duplicationTest() throws Exception {
        DataSource dataSource = getDataSource("jdbc:mysql://192.168.0.92:3306/oauth2?useSSL=false&characterEncoding=utf-8", "com.mysql.cj.jdbc.Driver"
                , "shh", "shh");
        DBManager dbManager = new DBManager(dataSource);

        DBBatchConfig DBBatchConfig = new DBBatchConfig(dataSource);

        JobBuilderFactory jobBuilderFactory = DBBatchConfig.getJobBuilderFactory();

        StepBuilderFactory stepBuilderFactory = DBBatchConfig.getStepBuilderFactory();

        JobOperator jobOperator = DBBatchConfig.getJobOperator();

        JobRegistry jobRegistry = DBBatchConfig.getJobRegistry();

        JobExplorer jobExplorer = DBBatchConfig.getJobExplorer();

        JobRepository jobRepository = DBBatchConfig.getJobRepository();

        Set<JobExecution> test1 = jobExplorer.findRunningJobExecutions("test");
        for (JobExecution e: test1
             ) {
            System.out.println("jodid = "+e.getJobId());
            System.out.println("jod status = "+e.getStatus().name());
            //jobOperator.stop(e.getJobId());
            e.stop();
            e.setEndTime(new Date());
            e.upgradeStatus(BatchStatus.ABANDONED);
            jobRepository.update(e);
           // jobOperator.abandon(e.getJobId());
          //  jobOperator.abandon(e.getJobId());

        }


        TaskletStep step1 = stepBuilderFactory.get("step1").tasklet(new MyTasklet()).build();
        TaskletStep step1_1 = stepBuilderFactory.get("step1-1").tasklet(new MyTasklet()).build();
        TaskletStep step1_2 = stepBuilderFactory.get("step1-2").tasklet(new MyTasklet()).build();
        TaskletStep step2 = stepBuilderFactory.get("step2").tasklet(new MyTasklet2()).build();

        Job test = jobBuilderFactory.get("test").start(step1).next(step2)
                .listener(new JobExecutionListener() {
                    @Override
                    public void beforeJob(JobExecution jobExecution) {


                        System.out.println("beforeJob");
                    }

                    @Override
                    public void afterJob(JobExecution jobExecution) {
                        System.out.println("afterJob");
                    }
                }).build();

        JobExecution jobExecution1 = jobExplorer.getJobExecution(135l);
        jobExecution1.stop();
        Thread.sleep(8000);

        JobLauncher jobLauncher = DBBatchConfig.getJobLauncher();


        JobParameters jobParameters = new JobParametersBuilder().addLong("time", System.currentTimeMillis())
                .addString("jodId","77").toJobParameters();

        jobRegistry.register(new ReferenceJobFactory(test));
        JobExecution run = jobLauncher.run(test, jobParameters);



        Thread.sleep(8000);
        //run.stop();
        try {
            // run.stop();
            run.setEndTime(new Date());
            run.upgradeStatus(BatchStatus

                    .FAILED);
            jobRepository.update(run);
            JobExecution jobExecution = jobExplorer.getJobExecution(run.getJobId());
            Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
            for (StepExecution stepExecution:stepExecutions
                    ) {
                stepExecution.setEndTime(new Date());
                stepExecution.setStatus(BatchStatus.STOPPED);
                jobRepository.update(stepExecution);

            }


/*
            JobExecution jobExecution = jobExplorer.getJobExecution(run.getJobId());
            Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
            for (StepExecution stepExecution:stepExecutions
                    ) {
                Job test2 = jobRegistry.getJob("test");
                Step step = ((StepLocator)test2).getStep(stepExecution.getStepName());
                if (step instanceof TaskletStep) {
                    Tasklet tasklet = ((TaskletStep)step).getTasklet();
                    if (tasklet instanceof StoppableTasklet) {
                        StepSynchronizationManager.register(stepExecution);
                        ((StoppableTasklet)tasklet).stop();
                        StepSynchronizationManager.release();
                    }
                }
            }
*/




        }finally {

        }

        System.out.println("******************************");
        Thread.sleep(1000);
        JobExecution run1 = jobLauncher.run(test, jobParameters);



        // jobOperator.stop(run.getJobId());


        JobExecution jobExecution = jobExplorer.getJobExecution(run.getJobId());
        Long time = jobExecution.getJobParameters().getLong("time");
        System.out.println("para ="+time);


        System.in.read();



    }






   /* @Test */public void testSomeLibraryMethod() throws Exception {

        DataSource dataSource = getDataSource("jdbc:mysql://192.168.0.2:3306/oauth2?useSSL=false&characterEncoding=utf-8", "com.mysql.cj.jdbc.Driver"
                , "shh", "shh");
        DBManager dbManager = new DBManager(dataSource);

        DBBatchConfig DBBatchConfig = new DBBatchConfig(dataSource);



        JobBuilderFactory jobBuilderFactory = DBBatchConfig.getJobBuilderFactory();

        StepBuilderFactory stepBuilderFactory = DBBatchConfig.getStepBuilderFactory();

        TaskletStep step1 = stepBuilderFactory.get("step1").tasklet(new MyTasklet()).build();
        TaskletStep step2 = stepBuilderFactory.get("step2").tasklet(new MyTasklet2()).build();
        Job test = jobBuilderFactory.get("test").start(step1).next(step2)
                .build();


        Set<JobExecution> test2 = DBBatchConfig.getJobExplorer().findRunningJobExecutions("test");

        JobOperator s = DBBatchConfig.getJobOperator();

        MapJobRegistry mapJobRegistry = new MapJobRegistry();
        mapJobRegistry.register(new ReferenceJobFactory(test));




        JobExplorer jobExplorer = DBBatchConfig.getJobExplorer();
        JobExecution jobExecution = jobExplorer.getJobExecution(29L);
        Collection<StepExecution> stepExecutions = jobExecution.getStepExecutions();
        for (StepExecution ss:stepExecutions
                ) {
            System.out.println("exception = "+ss.getFailureExceptions().get(0));
        }

        List<Throwable> failureExceptions = jobExecution.getAllFailureExceptions();
        for (Throwable e:failureExceptions
             ) {
            System.out.println("exception = "+e.getMessage());
        }

        System.in.read();

        System.out.println("date + "+jobExecution.getEndTime());
        System.in.read();
        // mapJobRegistry.unregister("test");
        Job test1 = mapJobRegistry.getJob("test");


        JobLauncher jobLauncher = DBBatchConfig.getJobLauncher();
        JobParameters jobParameters = new JobParametersBuilder().addLong("time", System.currentTimeMillis())
                .toJobParameters();

        JobExecution run = jobLauncher.run(test, jobParameters);


        System.in.read();

        for (JobExecution j: test2
             ) {
            System.out.println(j.getId());
            s.stop(j.getJobId());
        }
        System.in.read();





        ;


        System.out.println(test);
        System.in.read();
       // jobLauncher.run(test,jobParameters);

    }








}
